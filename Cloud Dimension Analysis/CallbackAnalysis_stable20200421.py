import json
import dash
import dash_core_components as dcc
import dash_html_components as html
import numpy as np
import open3d as o3d
import plotly.graph_objects as go
import plotly.express as px
from dash.dependencies import Input, Output, State
import vector3d
import math
from scipy.cluster.vq import kmeans
import base64
import os

#VARIABLES_____________________________________________________________________________________________
#Dash related
external_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']
app = dash.Dash(__name__, external_stylesheets=external_stylesheets)

#Input from grasshopper based on the digital 3d model
pathDimCloud1 = "cloud1.xyz"   #start points of dimensions
pathDimCloud2 = "cloud2.xyz"   #end points of dimensions
red = [1, 0, 0]                #color assigned to them

#Input from scanner based on scanned geometry
pathScanCloud = "RoyalT_faketrackers.ply"
grey = [0.5, 0.5, 0.5]
downSize = 20

#Search parameters
searchRadius = 20

#Input mesh for vizualization
mesh = o3d.io.read_triangle_mesh("musikmeshSINGLE.ply")

#input for dim tolerance
tolerance = 3
subValue_0 = 20
toleranceSelect_0 = 3

resultsX = []
resultsY = []
resultsZ = []
resultsID = []

#FUNCTIONS DECLARATION_________________________________________________________________________________
#Processing
def loadCloud(path, color,bool):
    # Cloud path, color for display, bool to make kd tree

    # load cloud for nearest point search
    cloud = o3d.io.read_point_cloud(path)
    print(cloud, "has been loaded successfully")
    cloud.paint_uniform_color(color)

    #create KDtree
    if bool == True:
        tree = o3d.geometry.KDTreeFlann(cloud)
        print("KDtree has been created")
        return cloud, tree
    else:
        return cloud
def runSearch(tree,ScanCloud,DimCloud):
    #KD tree to search in, Cloud that defines anchor points

    #Perform search
    closestPtIdxList = []
    i = 0
    for p in DimCloud.points:
        searchOutput = [k, idx, dist] = tree.search_knn_vector_3d(DimCloud.points[i], 2)
        #first point is point itself. First tuple item is how many points found, second is their index in the cloud, the third is the distance to anchor
        indexes = searchOutput[1]
        closestPtIdx = indexes[0]  # we can use idx 0 here because we are searching in another cloud
        pcd.colors[closestPtIdx] = [0, 0, 1]  # colour it in blue
        closestPtIdxList.append(closestPtIdx)
        i += 1
    print("Indexes of cloud closest points found",closestPtIdxList)

    #Convert to results to numpy array
    pList = []
    for i in range(len(closestPtIdxList)):
        p = ScanCloud.points[closestPtIdxList[i]]
        pList.append(p)
    pArray = np.row_stack(pList)    #this creates an array (15, 3) of pointcloud coordinates p1 for standard dimensions
    #np.savetxt("Cloudp1.txt",pArray, fmt= '%f')
    print("points have been stored in numpy array")

    return pArray

#Mesh Viz
def create_mesh(mesh):
    #3d mesh that lives in directory
    mesh_pts = np.asarray(mesh.vertices)
    mesh_tris = np.asarray(mesh.triangles)
    print("mesh metadata created")
    return go.Figure(data=[go.Mesh3d(name='3D Model', x = mesh_pts[:, 0], y = mesh_pts[:, 1], z = mesh_pts[:, 2], i=mesh_tris[:,0], j=mesh_tris[:,1], k=mesh_tris[:,2], color='gray', opacity=0.85)])
def createMeshDimPoints(cloud):
    #Start/End Point Cloud with the standard dimension points exported from grasshopper
    array = np.asarray(cloud.points)  #because we are loading the cloud as xyz
    meshX = array[:, 0]
    meshY = array[:, 1]
    meshZ = array[:, 2]
    print("mesh dimension points created")
    return array, go.Scatter3d(x=meshX, y=meshY, z=meshZ, mode='markers', marker=dict(color='red', size=3))

#CloudViz
def create_cloud(cloud, downsample):
    #cloud that has already been loaded and lives in the directory
    downpcd = cloud.voxel_down_sample(voxel_size=int(downsample))
    array = np.asarray(downpcd.points)
    print("light cloud metadata created")

    return go.Figure(data=[go.Scatter3d(x=array[:, 0], y=array[:, 1], z=array[:, 2],mode='markers', marker=dict(color='gray' , size=1))])

def create_cloud_trace(cloud, downsample):
    #cloud that has already been loaded and lives in the directory
    downpcd = cloud.voxel_down_sample(voxel_size=int(downsample))
    array = np.asarray(downpcd.points)
    print("light cloud metadata created")

    return go.Scatter3d(x=array[:, 0], y=array[:, 1], z=array[:, 2],mode='markers', marker=dict(color='gray' , size=1))

def createCloudDimPoints(array):
    #Start/end points array that have been generated by the processing part of the script
    meshX = array[:, 0]
    meshY = array[:, 1]
    meshZ = array[:, 2]
    print("cloud dimension points created")
    return go.Scatter3d(x=meshX, y=meshY, z=meshZ, mode='markers', marker=dict(color='red', size=3))

#DimViz                                             #this works for both cloud and mesh
def create_dimLines(array1,array2):
    #array of start points, array of end points

    #to display lines properly, the coordinates must be interwoven
    xArray1 = array1[:, 0]
    xArray2 = array2[:, 0]
    ptX = np.empty((xArray1.size + xArray2.size), dtype = xArray1.dtype)
    ptX[0::2] = xArray1
    ptX[1::2] = xArray2
    ptX.tolist()
    #print(ptX)

    yArray1 = array1[:, 1]
    yArray2 = array2[:, 1]
    ptY = np.empty((yArray1.size + yArray2.size), dtype = yArray1.dtype)
    ptY[0::2] = yArray1
    ptY[1::2] = yArray2
    ptY.tolist()
    #print(ptY)

    zArray1 = array1[:, 2]
    zArray2 = array2[:, 2]
    ptZ = np.empty((zArray1.size + zArray2.size), dtype = zArray1.dtype)
    ptZ[0::2] = zArray1
    ptZ[1::2] = zArray2
    ptZ.tolist()
    #print(ptZ)

    lines= []
    #Create a trace for each line, points 2 by 2
    for i in range(len(ptX)-1):
        xlinePt = np.array([ptX[i], ptX[i+1]])
        ylinePt = np.array([ptY[i], ptY[i+1]])
        zlinePt = np.array([ptZ[i], ptZ[i+1]])

        #Show every second line
        if i % 2 == 0:
            lines.append(go.Scatter3d(x=xlinePt, y=ylinePt, z=zlinePt, mode="lines", marker=dict(color='red', size=6)))

    print("dimension lines created")
    return lines

def create_dimText_mesh(array1, array2):
    # array of start points, array of end points, figure to apply to

    #locate midpoints (location for text display)
    midpointsX = ((array2[:, 0]) + (array1[:, 0])) / 2
    midpointsY = ((array2[:, 1]) + (array1[:, 1])) / 2
    midpointsZ = ((array2[:, 2]) + (array1[:, 2])) / 2
    print("midpoints have been calculated")

    #find cloud centroid
    rawCentroid = kmeans(np.asarray(pcd.points), 1)
    centroid = rawCentroid[0]
    centX = centroid[:, 0]
    centY = centroid[:, 1]
    centZ = centroid[:, 2]

    #Calculate vector between center and midpoints
    vecX = (midpointsX) - (centX)
    vecY = (midpointsY) - (centY)
    vecZ = (midpointsZ) - (centZ)

    #Calculate Vector Amplitude
    VcompX = vecX ** 2
    VcompY = vecY ** 2
    VcompZ = vecZ ** 2
    Vsum = VcompX + VcompY + VcompZ
    Vmag = np.sqrt(Vsum)

    #Calculate Unit vector
    uVecX = vecX / Vmag
    uVecY = vecY / Vmag
    uVecZ = vecZ / Vmag

    #Move midpoints by unit vector
    dispX = midpointsX + (uVecX * 150)
    dispY = midpointsY + (uVecY * 150)
    dispZ = midpointsZ
    print("midpoints have been offset")

    # Calculate distance
    compX = ((array2[:, 0]) - (array1[:, 0])) ** 2
    compY = ((array2[:, 1]) - (array1[:, 1])) ** 2
    compZ = ((array2[:, 2]) - (array1[:, 2])) ** 2
    sum = compX + compY + compZ
    dist = np.sqrt(sum)
    global distN_mesh
    distN_mesh = np.round(dist, 0)
    print("distances have been calculated")

    return distN_mesh, go.Scatter3d(x=dispX, y=dispY, z=dispZ, mode='text', text=distN_mesh, textposition='middle center', textfont=dict(color="red"))
    #if we want to make different colours, it needs to be here, create a list of go.scatter like in lines

def create_dimText_cloud(array1, array2, distN_mesh,value):
    # array of start points, array of end points, figure to apply to

    #locate midpoints (location for text display)
    midpointsX = ((array2[:, 0]) + (array1[:, 0])) / 2
    midpointsY = ((array2[:, 1]) + (array1[:, 1])) / 2
    midpointsZ = ((array2[:, 2]) + (array1[:, 2])) / 2
    print("midpoints have been calculated")

    #find cloud centroid
    rawCentroid = kmeans(np.asarray(pcd.points), 1)
    centroid = rawCentroid[0]
    centX = centroid[:, 0]
    centY = centroid[:, 1]
    centZ = centroid[:, 2]

    #Calculate vector between center and midpoints
    vecX = (midpointsX) - (centX)
    vecY = (midpointsY) - (centY)
    vecZ = (midpointsZ) - (centZ)

    #Calculate Vector Amplitude
    VcompX = vecX ** 2
    VcompY = vecY ** 2
    VcompZ = vecZ ** 2
    Vsum = VcompX + VcompY + VcompZ
    Vmag = np.sqrt(Vsum)

    #Calculate Unit vector
    uVecX = vecX / Vmag
    uVecY = vecY / Vmag
    uVecZ = vecZ / Vmag

    #Move midpoints by unit vector
    dispX = midpointsX + (uVecX * 150)
    dispY = midpointsY + (uVecY * 150)
    dispZ = midpointsZ
    print("midpoints have been offset")

    # Calculate distance
    compX = ((array2[:, 0]) - (array1[:, 0])) ** 2
    compY = ((array2[:, 1]) - (array1[:, 1])) ** 2
    compZ = ((array2[:, 2]) - (array1[:, 2])) ** 2
    sum = compX + compY + compZ
    dist = np.sqrt(sum)
    distN_cloud = np.round(dist, 0)
    print("distances have been calculated")

    distBlue = []
    distGreen = []
    distRed = []

    coorX = []
    coorY = []
    coorZ = []
    print(len(distN_cloud))
    for i in range(len(distN_cloud)):

        diff = distN_cloud[i] - distN_mesh[i]
        curr = np.round(distN_cloud[i],0)
        coorX.append(dispX[i])
        coorY.append(dispY[i])
        coorZ.append(dispZ[i])

        if diff <= -(value) :
            distBlue.append(go.Scatter3d(x=coorX, y=coorY, z=coorZ, mode='text', text=int(curr), textposition='middle center', textfont=dict(color="blue")))
            print("added to blue")
        if distN_cloud[i] - distN_mesh[i] >= (value):
            distRed.append(go.Scatter3d(x=coorX, y=coorY, z=coorZ, mode='text', text=int(curr), textposition='middle center', textfont=dict(color="red")))
            print("added to red")
        if -(value - 1) <= distN_cloud[i] - distN_mesh[i] <= (value - 1):
            distGreen.append(go.Scatter3d(x=coorX, y=coorY, z=coorZ, mode='text', text=int(curr), textposition='middle center',textfont=dict(color="green")))
            print("added to green")
        coorX.clear()
        coorY.clear()
        coorZ.clear()

    allDistCloud = distBlue + distGreen + distRed

    return allDistCloud



#Adapted to accomodate the callback data structure
def create_CallbackdimText(array1, array2):
    # array of start points, array of end points
    # array of start points, array of end points

    # locate midpoints (location for text display)
    midpointsX = np.array(((array2[0]) + (array1[0])) / 2)
    midpointsY = np.array(((array2[1]) + (array1[1])) / 2)
    midpointsZ = np.array(((array2[2]) + (array1[2])) / 2)
    print("midpoints have been calculated")

    # Calculate distance
    compX = ((array2[0]) - (array1[0])) ** 2
    compY = ((array2[1]) - (array1[1])) ** 2
    compZ = ((array2[2]) - (array1[2])) ** 2
    sum = compX + compY + compZ
    dist = np.sqrt(sum)
    distN = np.array(dist.astype(int))
    print("distances have been calculated")
    return go.Scatter3d(x=midpointsX, y=midpointsY, z=midpointsZ, mode='text', text=distN, textposition='top center',
                        textfont=dict(color="red"))

    #locate midpoints (location for text display)
#LOAD CLOUDS AND CREATE TREE
d1pcd = loadCloud(pathDimCloud1,red, False)
d2pcd = loadCloud(pathDimCloud2,red, False)
pcd, pcd_tree = loadCloud(pathScanCloud,grey,True)

#RUN KNN SEARCH
cldStartPtArray = runSearch(pcd_tree,pcd,d1pcd)      #Start point cloud dimensions
cldPEndPtArray = runSearch(pcd_tree,pcd,d2pcd)      #End point cloud dimensions

#Viz on o3d
# o3d.visualization.draw_geometries([d1pcd + d2pcd +pcd])
# print("")

#DASH_METADATA PREP___________________________________________________________________________________________________________
#VIZUALIZE MESH
meshStartpts, dashInfoStart = createMeshDimPoints(d1pcd)
meshEndpts, dashInfoEnd = createMeshDimPoints(d2pcd)

m = create_mesh(mesh)
m.add_trace(dashInfoStart)                                                    #Create start points
m.add_trace(dashInfoEnd)                                                     #Create end points
lines_mesh = create_dimLines(meshStartpts, meshEndpts)                                 #create dimension lines
meshDimensionText = create_dimText_mesh(meshStartpts,meshEndpts)[1]
m.add_trace(meshDimensionText)                                                #Create dimension text
for item in lines_mesh:
    m.add_trace(item)
m.update_layout(scene_aspectmode='data',showlegend=False, uirevision=True, scene = dict(xaxis = dict(title='', showbackground=False,showticklabels=False),yaxis = dict(title='', showbackground=False,showticklabels=False),zaxis = dict(title='', showbackground=False,showticklabels=False)), width=800, height=450, margin=dict(r=0, l=0, b=10, t=10)),

distN_mesh = create_dimText_mesh(meshStartpts,meshEndpts)[0]

#VIZUALIZE CLOUD
c = create_cloud(pcd,downSize)
trace_startpts = createCloudDimPoints(cldStartPtArray) #Create start points AS SCATTER3D
trace_endpts = createCloudDimPoints(cldPEndPtArray)    #Create end points AS SCATTER3D
trace_dimtext = create_dimText_cloud(cldStartPtArray, cldPEndPtArray,distN_mesh,tolerance)   #Create dimension text as SCATTER 3d
traces = [trace_startpts,trace_endpts] #put all in one list of SCATTER3D
trace_dimlines = create_dimLines(cldStartPtArray,cldPEndPtArray) #Create dimension lines AS LIST

traces.extend(trace_dimlines)
exceptDimText = traces
allTraces = []
allTraces = exceptDimText
allTraces.extend(trace_dimtext)        #Put everything in one list

# print ("traces", traces)
for item in allTraces:
    c.add_trace(item)
c.update_layout(scene_aspectmode='data',showlegend=False, uirevision=True, scene = dict(xaxis = dict(title='', showbackground=False,showticklabels=False),yaxis = dict(title='', showbackground=False,showticklabels=False),zaxis = dict(title='', showbackground=False,showticklabels=False)), width=800, height=450, margin=dict(r=0, l=0, b=10, t=10)),
#
#
#PUSH TO INTERFACE___________________________________________________________________________________________________________
print("initializing UI")

image_filename = os.path.join(os.getcwd(), 'gradient.png')
encoded_image = base64.b64encode(open(image_filename, 'rb').read())


app.layout = html.Div([

    html.H1("Precision Partner"),
    html.Div([
              html.P("Cloud Voxel Downsampling:", style={'height': 'auto','display':'inline'}),
              html.Div([dcc.Input(id='subValue', value='20', type='number', style={'height': 'auto', 'margin': '3px', 'verticalAlignment': 'middle'})]),
              html.Div([html.Button('Erase Trace', id='erase',style ={ 'height':'auto','margin':'3px'})]),
              #html.Div([dcc.Upload(id='upload-data', children=html.Div([html.A('Upload Files')]), style={'height': 'auto', 'margin': '10px', 'display': 'inline-block'}, multiple=True)])
              ], style=dict(display='flex', flexWrap='nowrap', width=2000, verticalAlignment='middle')),

    #ColourGradient
    html.Div([
            html.P("Select tolerance: ", style={'height': 'auto','display':'inline'}),
            html.Div([dcc.Dropdown(id='toleranceSelect', options=[{'label': 'Small', 'value': '3'},{'label': 'Large', 'value': '50'}], value='3', style ={'width':200, 'height':'auto','margin':'3px'})])
            ],style=dict(display='flex', flexWrap='nowrap', width=2000, verticalAlignment='middle')),

    html.Div([
              html.Div(id= 'neg'),
              html.Img(src='data:image/png;base64,{}'.format(encoded_image.decode())),
              html.Div(id = 'pos')],style=dict(display='flex', flexWrap='nowrap', width=2000, verticalAlignment='middle')),


    html.Div([
        html.Div(dcc.Graph(id='3d_scat', figure=c), style={'height': 'auto'}),
        html.Div(dcc.Graph(id='3d_mesh', figure=m), style={'height': 'auto'}),
    ], style=dict(display='flex', flexWrap='nowrap', width='99%', verticalAlignment='middle')),

])


#These two change the dim tolerance gradient annotation
@app.callback(Output('neg', 'children'),
            [Input('toleranceSelect', 'value')])
def update_neg(value):
    return ' -{}   '.format(value)

@app.callback(Output('pos', 'children'),
            [Input('toleranceSelect', 'value')])
def update_pos(value):
    return ' +{} '.format(value)


#This changes the voxel subsampling, the colour of the dimension text, and the manual dimensions
@app.callback(Output('3d_scat', 'figure'),
            [Input('subValue', 'value'),
             Input('toleranceSelect', 'value'),
             Input('3d_scat', 'clickData'),
             Input('erase', 'n_clicks')])

def changePlot(subValue,toleranceSelect,clickData, n_clicks):
    ctx = dash.callback_context
    ids = ctx.triggered

    name = ids[0]['prop_id'].split('.')[0]
    print(name)

    array1 = np.zeros((1,3))
    array2 = np.zeros((1,3))


    #cloud downsampling
    if name == 'subValue':
        if subValue < 10:
            return c
        else:
            print(subValue)
            c.data = []
            new_fig = create_cloud_trace(pcd, subValue)
            c.add_trace(new_fig)
            for item in allTraces:
                c.add_trace(item)
            return c

    #DimColour change
    elif name == 'toleranceSelect':
        print(name)

        cloudTrace = c.data[0]
        c.data = []
        c.add_trace(cloudTrace)

        trace_dimtext = create_dimText_cloud(cldStartPtArray, cldPEndPtArray, distN_mesh,int(toleranceSelect))

        newAllTraces = []
        newAllTraces = exceptDimText

        newAllTraces.extend(trace_dimtext)

        for item in newAllTraces:
            c.add_trace(item)
        print('done')
        return c

    #AddManual Dim
    elif name == '3d_scat':
        print(clickData)

        startX = []
        endX = []
        startY = []
        endY = []
        startZ = []
        endZ = []

        for p in clickData['points']:
            resultsX.append(clickData['points'][0]['x'])
            resultsY.append(clickData['points'][0]['y'])
            resultsZ.append(clickData['points'][0]['z'])
            resultsID.append(clickData['points'][0]['pointNumber'])

        print("resultsX", len(resultsX))

        for i in range(len(resultsX)):
            if i % 2 == 0:
                startX.append(resultsX[i])
                startY.append(resultsY[i])
                startZ.append(resultsZ[i])
            else:
                endX.append(resultsX[i])
                endY.append(resultsY[i])
                endZ.append(resultsZ[i])

        if len(startX) == len(endX):
            print("yes")

            arrStartX = np.asarray(startX)
            arrEndX = np.asarray(endX)
            arrStartY = np.asarray(startY)
            arrEndY = np.asarray(endY)
            arrStartZ = np.asarray(startZ)
            arrEndZ = np.asarray(endZ)

            array1 = np.array([arrStartX, arrStartY, arrStartZ])
            array2 = np.array([arrEndX, arrEndY, arrEndZ])

            c.add_trace(create_CallbackdimText(array1, array2))
            c.add_trace(go.Scatter3d(mode='markers',x=resultsX,y=resultsY,z=resultsZ, marker=dict(color='red',size=5),showlegend=False))

            lines = []
            for i in range(len(resultsX) - 1):
                xlinePt = np.array([resultsX[i], resultsX[i + 1]])
                ylinePt = np.array([resultsY[i], resultsY[i + 1]])
                zlinePt = np.array([resultsZ[i], resultsZ[i + 1]])

                # Show every second line
                if i % 2 == 0:
                    lines.append(
                        go.Scatter3d(x=xlinePt, y=ylinePt, z=zlinePt, mode="lines", marker=dict(color='red', size=6)))

            for item in lines:
                c.add_trace(item)

            return c

        else:
            print("no")
            c.add_trace(go.Scatter3d(mode='markers', x=resultsX, y=resultsY, z=resultsZ, marker=dict(color='red', size=5), showlegend=False))

            return c

    elif name == 'erase':
        resultsX.clear()
        resultsY.clear()
        resultsZ.clear()
        resultsID.clear()
        print("clickdata Cleared")

        cloudTrace = c.data[0]
        c.data = []
        c.add_trace(cloudTrace)
        for item in allTraces:
            c.add_trace(item)

        return c

if __name__ == '__main__':
    app.run_server(debug=True)