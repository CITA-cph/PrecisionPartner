import json
import dash
import dash_core_components as dcc
import dash_html_components as html
import numpy as np
import open3d as o3d
import plotly.graph_objects as go
import plotly.express as px
from dash.dependencies import Input, Output, State
import vector3d
import math
from scipy.cluster.vq import kmeans


#VARIABLES_____________________________________________________________________________________________
#Dash related
external_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']
app = dash.Dash(__name__, external_stylesheets=external_stylesheets)

#Input from grasshopper based on the digital 3d model
pathDimCloud1 = "cloud1.xyz"   #start points of dimensions
pathDimCloud2 = "cloud2.xyz"   #end points of dimensions
red = [1, 0, 0]                #color assigned to them

#Input from scanner based on scanned geometry
pathScanCloud = "RoyalT_faketrackers.ply"
grey = [0.5, 0.5, 0.5]
downSize = 10

#Search parameters
searchRadius = 20

#Input mesh for vizualization
mesh = o3d.io.read_triangle_mesh("musikmeshSINGLE.ply")

#FUNCTIONS DECLARATION_________________________________________________________________________________
#Processing
def loadCloud(path, color,bool):
    # Cloud path, color for display, bool to make kd tree

    # load cloud for nearest point search
    cloud = o3d.io.read_point_cloud(path)
    print(cloud, "has been loaded successfully")
    cloud.paint_uniform_color(color)

    #create KDtree
    if bool == True:
        tree = o3d.geometry.KDTreeFlann(cloud)
        print("KDtree has been created")
        return cloud, tree
    else:
        return cloud
def runSearch(tree,ScanCloud,DimCloud):
    #KD tree to search in, Cloud that defines anchor points

    #Perform search
    closestPtIdxList = []
    i = 0
    for p in DimCloud.points:
        searchOutput = [k, idx, dist] = tree.search_knn_vector_3d(DimCloud.points[i], 2)
        #first point is point itself. First tuple item is how many points found, second is their index in the cloud, the third is the distance to anchor
        indexes = searchOutput[1]
        closestPtIdx = indexes[0]  # we can use idx 0 here because we are searching in another cloud
        pcd.colors[closestPtIdx] = [0, 0, 1]  # colour it in blue
        closestPtIdxList.append(closestPtIdx)
        i += 1
    print("Indexes of cloud closest points found",closestPtIdxList)

    #Convert to results to numpy array
    pList = []
    for i in range(len(closestPtIdxList)):
        p = ScanCloud.points[closestPtIdxList[i]]
        pList.append(p)
    pArray = np.row_stack(pList)    #this creates an array (15, 3) of pointcloud coordinates p1 for standard dimensions
    #np.savetxt("Cloudp1.txt",pArray, fmt= '%f')
    print("points have been stored in numpy array")

    return pArray

#Mesh Viz
def create_mesh(mesh):
    #3d mesh that lives in directory
    mesh_pts = np.asarray(mesh.vertices)
    mesh_tris = np.asarray(mesh.triangles)
    print("mesh metadata created")
    return go.Figure(data=[go.Mesh3d(name='3D Model', x = mesh_pts[:, 0], y = mesh_pts[:, 1], z = mesh_pts[:, 2], i=mesh_tris[:,0], j=mesh_tris[:,1], k=mesh_tris[:,2], color='gray', opacity=0.85)])
def createMeshDimPoints(cloud):
    #Start/End Point Cloud with the standard dimension points exported from grasshopper
    array = np.asarray(cloud.points)  #because we are loading the cloud as xyz
    meshX = array[:, 0]
    meshY = array[:, 1]
    meshZ = array[:, 2]
    print("mesh dimension points created")
    return array, go.Scatter3d(x=meshX, y=meshY, z=meshZ, mode='markers', marker=dict(color='red', size=3))

#CloudViz
def create_cloud(cloud, downsample):
    #cloud that has already been loaded and lives in the directory
    downpcd = cloud.voxel_down_sample(voxel_size=int(downsample))
    array = np.asarray(downpcd.points)
    print("light cloud metadata created")

    return go.Figure(data=[go.Scatter3d(x=array[:, 0], y=array[:, 1], z=array[:, 2],mode='markers', marker=dict(color='gray' , size=1))])
def createCloudDimPoints(array):
    #Start/end points array that have been generated by the processing part of the script
    meshX = array[:, 0]
    meshY = array[:, 1]
    meshZ = array[:, 2]
    print("cloud dimension points created")
    return go.Scatter3d(x=meshX, y=meshY, z=meshZ, mode='markers', marker=dict(color='red', size=3))

#DimViz                                             #this works for both cloud and mesh
def create_dimLines(array1,array2,figure):
    #array of start points, array of end points

    #to display lines properly, the coordinates must be interwoven
    xArray1 = array1[:, 0]
    xArray2 = array2[:, 0]
    ptX = np.empty((xArray1.size + xArray2.size), dtype = xArray1.dtype)
    ptX[0::2] = xArray1
    ptX[1::2] = xArray2
    ptX.tolist()
    #print(ptX)

    yArray1 = array1[:, 1]
    yArray2 = array2[:, 1]
    ptY = np.empty((yArray1.size + yArray2.size), dtype = yArray1.dtype)
    ptY[0::2] = yArray1
    ptY[1::2] = yArray2
    ptY.tolist()
    #print(ptY)

    zArray1 = array1[:, 2]
    zArray2 = array2[:, 2]
    ptZ = np.empty((zArray1.size + zArray2.size), dtype = zArray1.dtype)
    ptZ[0::2] = zArray1
    ptZ[1::2] = zArray2
    ptZ.tolist()
    #print(ptZ)

    #Create a trace for each line, points 2 by 2
    for i in range(len(ptX)-1):
        xlinePt = np.array([ptX[i], ptX[i+1]])
        ylinePt = np.array([ptY[i], ptY[i+1]])
        zlinePt = np.array([ptZ[i], ptZ[i+1]])

        #Show every second line
        if i % 2 == 0:
            figure.add_trace(go.Scatter3d(x=xlinePt, y=ylinePt, z=zlinePt, mode="lines", marker=dict(color='red', size=5)))

    print("dimension lines created")
def create_dimText(array1, array2):
    # array of start points, array of end points, figure to apply to

    # locate midpoints (location for text display)
    midpointsX = ((array2[:, 0]) + (array1[:, 0])) / 2
    midpointsY = ((array2[:, 1]) + (array1[:, 1])) / 2
    midpointsZ = ((array2[:, 2]) + (array1[:, 2])) / 2
    print("midpoints have been calculated")

    # find cloud centroid
    rawCentroid = kmeans(np.asarray(pcd.points), 1)
    centroid = rawCentroid[0]
    centX = centroid[:, 0]
    centY = centroid[:, 1]
    centZ = centroid[:, 2]

    # Calculate vector between center and midpoints
    vecX = (midpointsX) - (centX)
    vecY = (midpointsY) - (centY)
    vecZ = (midpointsZ) - (centZ)

    # Calculate Vector Amplitude
    VcompX = vecX ** 2
    VcompY = vecY ** 2
    VcompZ = vecZ ** 2
    Vsum = VcompX + VcompY + VcompZ
    Vmag = np.sqrt(Vsum)

    # Calculate Unit vector
    uVecX = vecX / Vmag
    uVecY = vecY / Vmag
    uVecZ = vecZ / Vmag

    # Move midpoints by unit vector
    dispX = midpointsX + (uVecX * 150)
    dispY = midpointsY + (uVecY * 150)
    dispZ = midpointsZ
    print("midpoints have been offset")

    # Calculate distance
    compX = ((array2[:, 0]) - (array1[:, 0])) ** 2
    compY = ((array2[:, 1]) - (array1[:, 1])) ** 2
    compZ = ((array2[:, 2]) - (array1[:, 2])) ** 2
    sum = compX + compY + compZ
    dist = np.sqrt(sum)
    distN = np.round(dist, 0)
    print("distances have been calculated")

    return go.Scatter3d(x=dispX, y=dispY, z=dispZ, mode='text', text=distN, textposition='middle center',
                        textfont=dict(color="red"))

#Adapted to accomodate the callback data structure
def create_CallbackdimText(array1, array2):
    # array of start points, array of end points

    #locate midpoints (location for text display)
    midpointsX = np.array(((array2[0]) + (array1[0])) / 2)
    midpointsY = np.array(((array2[1]) + (array1[1])) / 2)
    midpointsZ = np.array(((array2[2]) + (array1[2])) / 2)
    print("midpoints have been calculated")
    print(midpointsX)
    print(midpointsY)
    print(midpointsZ)


    # Calculate distance
    compX = ((array2[0]) - (array1[0])) ** 2
    compY = ((array2[1]) - (array1[1])) ** 2
    compZ = ((array2[2]) - (array1[2])) ** 2
    sum = compX + compY + compZ
    dist = np.sqrt(sum)
    distN = np.round(dist, 2)
    print("distances have been calculated")
    return go.Scatter3d(x=midpointsX, y=midpointsY, z=midpointsZ, mode='text', text=distN, textposition='top center', textfont=dict(color="red"))

#PROCESSING_______________________________________________________________________________________________________
#LOAD CLOUDS AND CREATE TREE
d1pcd = loadCloud(pathDimCloud1,red, False)
d2pcd = loadCloud(pathDimCloud2,red, False)
pcd, pcd_tree = loadCloud(pathScanCloud,grey,True)

#RUN KNN SEARCH
cldStartPtArray = runSearch(pcd_tree,pcd,d1pcd)      #Start point cloud dimensions
cldPEndPtArray = runSearch(pcd_tree,pcd,d2pcd)      #End point cloud dimensions

#Viz on o3d
# o3d.visualization.draw_geometries([d1pcd + d2pcd +pcd])
# print("")

#DASH_METADATA PREP___________________________________________________________________________________________________________
#VIZUALIZE MESH
meshStartpts, dashInfoStart = createMeshDimPoints(d1pcd)
meshEndpts, dashInfoEnd = createMeshDimPoints(d2pcd)

m = create_mesh(mesh)
m.add_trace(dashInfoStart)                                                    #Create start points
m.add_trace(dashInfoEnd)                                                     #Create end points
create_dimLines(meshStartpts, meshEndpts, m)                                 #create dimension lines
m.add_trace(create_dimText(meshStartpts,meshEndpts))                         #Create dimension text
m.update_layout(scene_aspectmode='data', scene = dict(xaxis = dict(title='', showbackground=False,showticklabels=False),yaxis = dict(title='', showbackground=False,showticklabels=False),zaxis = dict(title='', showbackground=False,showticklabels=False)), width=800, height=450, margin=dict(r=0, l=0, b=10, t=10)),

#VIZUALIZE CLOUD
c = create_cloud(pcd,downSize)
c.add_trace(createCloudDimPoints(cldStartPtArray))                        #Create start points
c.add_trace(createCloudDimPoints(cldPEndPtArray))                         #Create end points
create_dimLines(cldStartPtArray,cldPEndPtArray,c)                         #Create dimension lines
c.add_trace(create_dimText(cldStartPtArray, cldPEndPtArray))                     # Create dimension text
c.update_layout(scene_aspectmode='data', scene = dict(xaxis = dict(title='', showbackground=False,showticklabels=False),yaxis = dict(title='', showbackground=False,showticklabels=False),zaxis = dict(title='', showbackground=False,showticklabels=False)), width=800, height=450, margin=dict(r=0, l=0, b=10, t=10)),


#PUSH TO INTERFACE___________________________________________________________________________________________________________
print("initializing UI")

app.layout = html.Div([

    html.H1("Precision Partner"),
    html.Div([
              html.P("3D scan's density:", style={'height': 'auto','display':'inline'}),
              html.Div([dcc.Input(id='subValue', value='10', type='number', style={'height': 'auto', 'margin': '3px', 'verticalAlignment': 'middle'})]),
              html.Div([html.Button('New Dimension', id='newDim',style ={ 'height':'auto','margin':'3px'})]),
              html.Div([html.Button('Erase Trace', id='erase',style ={ 'height':'auto','margin':'3px'})]),
              html.Div([dcc.Upload(id='upload-data', children=html.Div([html.A('Upload Files')]), style={'height': 'auto', 'margin': '10px', 'display': 'inline-block'}, multiple=True),])

              ], style=dict(display='flex', flexWrap='nowrap', width=2000, verticalAlignment='middle')),

    html.Div([
              html.Div('Selected Points:'),
              html.Div(id='selected_points'),
    ], style=dict(display='none', flexWrap='nowrap', width=2000, verticalAlignment='middle')),

    html.Div([
        html.Div(dcc.Graph(id='3d_scat', figure=c), style={'height': 'auto'}),
        html.Div(dcc.Graph(id='3d_mesh', figure=m), style={'height': 'auto'}),
    ], style=dict(display='flex', flexWrap='nowrap', width='99%', verticalAlignment='middle')),

])

totalClicks = 0
# newData = c.data[0]
# print(newData)
# #c.data = []
# c.update_layout( data=newData,scene_aspectmode='data', scene=dict(xaxis=dict(title='', showbackground=False, showticklabels=False),
#                                                     yaxis=dict(title='', showbackground=False, showticklabels=False),
#                                                     zaxis=dict(title='', showbackground=False, showticklabels=False)),
#                 width=800, height=450, margin=dict(r=0, l=0, b=10, t=10))


#
# """
# A callback has an output, input and runs a function
# the input is the "value" property of the component that has the ID "my-id"
# the output is the "children" property of the component with the ID "my-div".
# """
@app.callback(Output('selected_points', 'children'),
            [Input('3d_scat', 'clickData'),
            Input('newDim', 'n_clicks')],
            [State('selected_points', 'children')])

def select_point(clickData, clear_clicked, selected_points):
    ctx = dash.callback_context
    ids = [c['prop_id'] for c in ctx.triggered]
    if selected_points:
        results = json.loads(selected_points)
    else:
        results = []

    if '3d_scat.clickData' in ids:
        if clickData:
            for p in clickData['points']:
                if p not in results and len(results) < 2:
                    results.append(p)
    if 'newDim.n_clicks' in ids:
        results = []
    results = json.dumps(results)
    return results

@app.callback(Output('3d_scat', 'figure'),
            [Input('selected_points', 'children'),
             #Input('erase', 'n_clicks'),
            Input(component_id='subValue', component_property='value')])

def chart_3d( selected_points, downsample):
    # if n_clicks_timestamp > (datetime.datetime.now().timestamp.()-1 second):
    # if 'erase.n_clicks' > totalClicks:
    #     c.update_layout(data= 0)

    c.update_layout(scene_aspectmode='data', scene = dict(xaxis = dict(title='', showbackground=False,showticklabels=False),yaxis = dict(title='', showbackground=False,showticklabels=False),zaxis = dict(title='', showbackground=False,showticklabels=False)), width=800, height=450, margin=dict(r=0, l=0, b=10, t=10))
    downpcd = pcd.voxel_down_sample(voxel_size=int(downsample))  #see if this can not be hardcoded
    selected_points = json.loads(selected_points) if selected_points else []
    if selected_points:
        print(selected_points)
        c.add_trace(go.Scatter3d(
                mode='markers+lines',
                x=[p['x'] for p in selected_points],
                y=[p['y'] for p in selected_points],
                z=[p['z'] for p in selected_points],
                marker=dict(
                    color='red',
                    size=5
                ),
                showlegend=False
            )
        )
        idx = [p['pointNumber'] for p in selected_points]
        if len(idx) == 2:   #if two points are selected, display the dimension
            print(idx)
            dimStartArray = downpcd.points[idx[0]]
            print(dimStartArray)
            dimEndArray = downpcd.points[idx[1]]
            print(dimEndArray)
            c.add_trace(create_CallbackdimText(dimStartArray, dimEndArray))

    return c

if __name__ == '__main__':
    app.run_server(debug=True)